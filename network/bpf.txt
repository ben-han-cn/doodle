BPF 
  programming compile to bytecode
  bytecode will be execute on vm in linux kernel

cBPF == classic berkeley package filter which is mainly focus on filtering network packets
eBPF == extended BPF 
the difference is the ISA of vm is redesigned, support 64 bit register
these days, BPF == eBPF

eBPF has in-kernel verifier which will verify the user code
which will be executed in kernel mode is safe enough

BCC == BPF compiler collection which is a BPF frontend library

BPF map
maps is a generic storage of different types for sharing data between kernel and userspace
The maps are accessed from user space via BPF syscall, which has commands:
  create a map with given type and attributes
  map_fd = bpf(BPF_MAP_CREATE, union bpf_attr *attr, u32 size)
  lookup key/value, update, delete, iterate, delete a map
userspace programs use this syscall to create/access maps that BPF programs are concurrently updating 


BPF used in two aspect:
1 kernel trace:
  Kprobes, pref event
  Uprobes, USDT(user-level statically define tracing)
  (Kprobes, Uprobes is dynamic, Tracepoints is static)
    
2 network packet management
  XDP, tc(traffic control)

3 security
  LSM(linux security module) hook

XDP:
Framework for running BPF programs in driverâ€™s RX path
(dpdk related kernel by pass tech to enhance network performance is to move all the network 
pkt processing from kernel to user space, and XDP does in fact the opposite) 

seccomp is based on eBPF
