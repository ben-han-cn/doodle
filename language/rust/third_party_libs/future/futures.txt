pub trait Future {
    type Item;
    type Error;
    fn poll(&mut self) -> Poll<Self::Item, Self::Error>;

    fn wait(self) -> result::Result<Self::Item, Self::Error> {
        ::executor::spawn(self).wait_future()
    }
}

pub type Poll<T, E> = Result<Async<T>, E>; 
#[derive(Copy, Clone, Debug, PartialEq)]
pub enum Async<T> {
    Ready(T),
    NotReady,
}


//implememt a future
pub struct FutureResult<T, E> {
    inner: Option<result::Result<T, E>>,
}

impl<T, E> Future for FutureResult<T, E> {
    type Item = T;
    type Error = E;
    fn poll(&mut self) -> Poll<T, E> {
        self.inner.take().expect("cannot poll Result twice").map(Async::Ready)
    }
}

fn result<T, E>(r: Result<T, E>) -> FutureResult<T, E> {
    FutureResult{ inner: Some(r) }
}

fn done<T: Send + 'static>(t: T) -> Box<Future<Item = T, Error = ()> + Send> {
    Box::new(result(Ok(10)))
}

//run the future
fn main() {
    let pool = CpuPool::new(2);
    let a = pool.spawn(done(10));
    println!("num is {}", a.wait().unwarp());
}


//cpupool spwan
pub fn spawn<F>(&self, f: F) -> CpuFuture<F::Item, F::Error>
        where F: Future + Send + 'static,
              F::Item: Send + 'static,
              F::Error: Send + 'static,
    {   
        let (tx, rx) = channel();
        let keep_running_flag = Arc::new(AtomicBool::new(false));
        // AssertUnwindSafe is used here because `Send + 'static` is basically
        // an alias for an implementation of the `UnwindSafe` trait but we can't
        // express that in the standard library right now.
        let sender = MySender {
            fut: AssertUnwindSafe(f).catch_unwind(),
            tx: Some(tx),
            keep_running_flag: keep_running_flag.clone(),
        };  
        #[allow(deprecated)]
        executor::spawn(sender).execute(self.inner.clone());
        CpuFuture { inner: rx , keep_running_flag: keep_running_flag.clone() }
    }

//--> ::executor::spawn(CpuFuture).wait_future()


//executor::spawn
pub fn spawn<T>(obj: T) -> Spawn<T> {
    Spawn {
        id: fresh_task_id(),
        obj: obj,
        data: local_map(),
    }   
}

impl<F: Future> Spawn<F> {
    pub fn wait_future(&mut self) -> Result<F::Item, F::Error> {
         ThreadNotify::with_current(|notify| {
             loop {
                 match self.poll_future_notify(notify, 0)? {
                     Async::NotReady => notify.park(),
                     Async::Ready(e) => return Ok(e),
                 }
             }
         })
     }
}

//set future task into current thread local data
//call the pool of the future
impl<T: ?Sized> Spawn<T> {
    pub fn poll_future_notify<N>(&mut self,
                                 notify: &N,
                                 id: usize) -> Poll<T::Item, T::Error>
        where N: Clone + Into<NotifyHandle>,
              T: Future,
    {
        let mk = || notify.clone().into();
        self.enter(BorrowedUnpark::new(&mk, id), |f| f.poll())
    }

    fn enter<F, R>(&mut self, unpark: BorrowedUnpark, f: F) -> R
        where F: FnOnce(&mut T) -> R
    {
        let borrowed = BorrowedTask {
            id: self.id,
            unpark: unpark,
            events: BorrowedEvents::new(),
            map: &self.data,
        };
        let obj = &mut self.obj;
        set(&borrowed, || f(obj))
    }
}

//if future isn't ready, it will park the thread
//use notify to wake up the sleep thread which waiting for
//condition and poll again
impl ThreadNotify {
    fn park(&self) {
        match self.state.compare_and_swap(NOTIFY, IDLE, Ordering::SeqCst) {
            NOTIFY => return,
            IDLE => {}, 
            _ => unreachable!(),
        }   

        let mut m = self.mutex.lock().unwrap();
        match self.state.compare_and_swap(IDLE, SLEEP, Ordering::SeqCst) {
            NOTIFY => {
                self.state.store(IDLE,
                                 Ordering::SeqCst);
                return;
            }   
            IDLE => {}, 
            _   => unreachable!(),
        }   

        loop {
            m = self.condvar.wait(m).unwrap();
            if NOTIFY == self.state.compare_and_swap(NOTIFY, IDLE, Ordering::SeqCst) { 
                return;
            }   
        }   
    }   

    fn notify(&self, _unpark_id: usize) {
        match self.state.compare_and_swap(IDLE, NOTIFY, Ordering::SeqCst) {
            IDLE | NOTIFY => return,
            SLEEP => {}
            _ => unreachable!(),
        }   

        let _m = self.mutex.lock().unwrap();
        match self.state.compare_and_swap(SLEEP, NOTIFY, Ordering::SeqCst) {
            SLEEP => {}
            _ => return,
        }   

        self.condvar.notify_one();
    }   
}


//notify notready task, the task could be get in pool function
struct MyFuture {
    signal: Arc<Mutex<bool>>,
    value: u32,
}

impl MyFuture {
    fn new(v: u32) -> Self {
        MyFuture {
            signal: Arc::new(Mutex::new(false)),
            value: v,
        }   
    }   
}

impl Future for MyFuture {
    type Item = u32;
    type Error = (); 
    fn poll(&mut self) -> Poll<Self::Item, Self::Error> {
        let signal = self.signal.lock().unwrap();
        if *signal == false {
            {   
                let task = task::current();
                let signal = self.signal.clone();  
                thread::spawn(move|| {
                    let mut flag = signal.lock().unwrap();
                    *flag = true;
                    task.notify();
                }); 
            }   
            Ok(Async::NotReady)
        } else {
            Ok(Async::Ready(self.value))
        }   
    }   
}


// cpupool execute the poll of future in a thread pool, and use channel to connect 
// the backgroud future with a channel pull future returned to current thread, cpupool
// is suitable for future which poll needs lots of cpu resource

// notifications happen at the task level and not the future level. When a task is 
// notified, it will poll its top-level future, which may result in any or all of the 
// child futures (if present) being polled. 


//future --> create task --> poll function call 
    1 if poll return not ready, it will block current thread, it's future's 
    responsibility to notify itself.
    2 in poll, current return the task related to this future
    3 if in the poll, furture notify current task, even poll return not ready, the
    task won't be parked which blocking the thread, and poll will be invoked again.
