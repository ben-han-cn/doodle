//tokio
pub trait Executor {
    fn spawn(&mut self, future: Box<Future<Item = (), Error = ()> + Send>) 
        -> Result<(), SpawnError>;

    fn status(&self) -> Result<(), SpawnError> {
        Ok(())
    }
}

//future
pub trait Executor<F: Future<Item = (), Error = ()>> {
    fn execute(&self, future: F) -> Result<(), ExecuteError<F>>;
}


//tokio multi-thread runtime
pub struct Runtime {
    inner: Option<Inner>,
}

#[derive(Debug)]
struct Inner {
    reactor: Handle,
    pool: threadpool::ThreadPool,
}

//tokio current thread runtime
#[derive(Debug)]
pub struct Runtime {
    reactor_handle: tokio_reactor::Handle,
    timer_handle: timer::Handle,
    clock: Clock,
    executor: CurrentThread<Timer<Reactor>>,
}


for tokio there are two kinds of runtime:
current_thread -> tokio::runtime::current_thread::Runtime
thread_pool -> tokio::runtime::Runtime

runtime.Run() ---> will set the DefaultExecutor to the related executor
so in the future code, it can use DefaultExecutor::current() to spawn new
future.

since current_thread executor won't pass task to other thread, so it
can spawn future which doesn't implement Send 


//run async io in one thread
use tokio::runtime::current_thread;
let (_tx, admin_shutdown_signal) = futures::sync::oneshot::channel::<()>();
{   
    thread::Builder::new()
        .name("admin".into())
        .spawn(move || {
            use api::tap::server::TapServer;

            let mut rt =
                current_thread::Runtime::new().expect("initialize admin thread runtime");

            let tap = serve_tap(control_listener, TapServer::new(observe));

            let metrics = control::serve_http(
                "metrics",
                metrics_listener,
                metrics::Serve::new(report),
            );  

            rt.spawn(::logging::admin().bg("resolver").future(resolver_bg));
            // tap is already pushped in a logging Future.
            rt.spawn(tap);
            // metrics_server is already pushped in a logging Future.
            rt.spawn(metrics);
            rt.spawn(::logging::admin().bg("dns-resolver").future(dns_bg));

            rt.spawn(::logging::admin().bg("tls-config").future(tls_cfg_bg));

            let shutdown = admin_shutdown_signal.then(|_| Ok::<(), ()>(()));
            rt.block_on(shutdown).expect("admin");
            trace!("admin shutdown finished");
        }).expect("initialize controller api thread");
    trace!("controller client thread spawned");
} 
