runtime
    reactor ---> run in a backgroud thread
    executor ---> thread pool to run futures, each worker in thread pool has a timer

tokio::run == 
    runtime = Runtime::new()
    runtime.spawn()
    runtime.shutdown()

runtime.spawn -> 
    threadpool.spawn ->
        sender.spawn ->
            prepare_for_spawn()
            pool.submit()


//spawn will submit the task to DefaultExecutor in current thread, 
//this function should be invoked in one scheduled future
//each thread in thread pool use thread local data to store DefaultExecutor
//each thread(worker) when started will call do_run to set the DefaultExecutor to 
//threadpool executor which created in runtime new, and threadpool executor will
//decide whether run the task in current thread or external thread
tokio::spawn -->  
    executor::spawn --> 
        ::tokio_executor::spawn(f) --> 
            DefaultExecutor::current().spawn()


tokio and futures share same Spawn structure, poll spawn if return not_ready will 
block current thread.


reactor
Establishing a TCP connection usually cannot be completed immediately.
[`TcpStream::connect`] does not block the current thread. Instead, it
returns a [future][connect-future] that resolves once the TCP connection has
been established. The connect future itself has no way of knowing when the
TCP connection has been established.

Before returning the future, [`TcpStream::connect`] registers the socket
with a reactor. This registration process, handled by [`Registration`], is
what links the [`TcpStream`] with the [`Reactor`] instance. At this point,
the reactor starts listening for connection events from the operating system
for that socket.

Once the connect future is passed to [`tokio::run`], it is spawned onto a
thread pool. The thread pool waits until it is notified that the connection
has completed.

When the TCP connection is established, the reactor receives an event from
the operating system. It then notifies the thread pool, telling it that the
connect future can complete. At this point, the thread pool will schedule
the task to run on one of its worker threads. This results in the `and_then`
closure to get executed.


//tokio
pub trait Executor {
    fn spawn(&mut self, future: Box<Future<Item = (), Error = ()> + Send>) 
        -> Result<(), SpawnError>;

    fn status(&self) -> Result<(), SpawnError> {
        Ok(())
    }
}

//future
pub trait Executor<F: Future<Item = (), Error = ()>> {
    fn execute(&self, future: F) -> Result<(), ExecuteError<F>>;
}


//tokio multi-thread runtime
pub struct Runtime {
    inner: Option<Inner>,
}

#[derive(Debug)]
struct Inner {
    reactor: Handle,
    pool: threadpool::ThreadPool,
}

//tokio current thread runtime
#[derive(Debug)]
pub struct Runtime {
    reactor_handle: tokio_reactor::Handle,
    timer_handle: timer::Handle,
    clock: Clock,
    executor: CurrentThread<Timer<Reactor>>,
}


for tokio there are two kinds of runtime:
current_thread -> tokio::runtime::current_thread::Runtime
thread_pool -> tokio::runtime::Runtime

runtime.Run() 
    set the DefaultExecutor
    set the DefaultReactor

so in the future code, it can use DefaultExecutor::current() to spawn new
future.
since current_thread executor won't pass task to other thread, so it
can spawn future which doesn't implement Send 

default reactor will make all the socket register to the correct reactor through
poll event

//run async io in one thread
use tokio::runtime::current_thread;
let (_tx, admin_shutdown_signal) = futures::sync::oneshot::channel::<()>();
{   
    thread::Builder::new()
        .name("admin".into())
        .spawn(move || {
            use api::tap::server::TapServer;

            let mut rt =
                current_thread::Runtime::new().expect("initialize admin thread runtime");

            let tap = serve_tap(control_listener, TapServer::new(observe));

            let metrics = control::serve_http(
                "metrics",
                metrics_listener,
                metrics::Serve::new(report),
            );  

            rt.spawn(::logging::admin().bg("resolver").future(resolver_bg));
            // tap is already pushped in a logging Future.
            rt.spawn(tap);
            // metrics_server is already pushped in a logging Future.
            rt.spawn(metrics);
            rt.spawn(::logging::admin().bg("dns-resolver").future(dns_bg));

            rt.spawn(::logging::admin().bg("tls-config").future(tls_cfg_bg));

            let shutdown = admin_shutdown_signal.then(|_| Ok::<(), ()>(()));
            rt.block_on(shutdown).expect("admin");
            trace!("admin shutdown finished");
        }).expect("initialize controller api thread");
    trace!("controller client thread spawned");
}
