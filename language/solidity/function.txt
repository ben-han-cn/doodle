function call based on input data
4 bytes to select method //kecccak256 hash of function signature
32 bytes for first parameter

parameter for dynamic array
32 byte point to the location in the tail section
tail section
  32 byte for len
  element
  element


when depoly a contract, binary data is send to null address, the binary data
compose of

1 deploy code
  this will run constructor function, and set up initial variables
  return the follow contract code to evm

2 contract code

3 aux data (optional) cryptographic fingerprint of the source code, used for validation

contractAddr = crypto.CreateAddress(caller.Address(), nonce)
//nonce is the id of the transaction
evm.StateDB.CreataAccount(contractAddr)


func makeLog(size int) executionFunc {
  return func(pc *uint64, evm *EVM, contract *Contract, memory *Memory, stack *Stack) ([]byte, error) {
    topics := make([]common.Hash, size)
    mStart, mSize := stack.pop(), stack.pop()
    for i := 0; i < size; i++ {
      topics[i] = common.BigToHash(stack.pop())
    }
    d := memory.Get(mStart.Int64(), mSize.Int64())
    evm.StateDB.AddLog(&types.Log{
      Address: contract.Address(),
      Topics:  topics,
      Data:    d,
      // This is a non-consensus field, but assigned here because
      // core/state doesn't know the current block number.
      BlockNumber: evm.BlockNumber.Uint64(),
    })
    evm.interpreter.intPool.put(mStart, mSize)
    return nil, nil
  }
}
log opcode will create log struct which belongs to contract, and it's stored in db
log struct has zero or more topics which are used to search/filter logs

solidity event
pragma solidity ^0.4.18;
contract Logger {
  event Log(uint256 a, uint256 b, uint256 c);
  function log(uint256 a, uint256 b, uint256 c) public {
    Log(a, b, c);
  }
}
first topic is used as event name

block header has bloom filter for all the logs generated by transactions included in this block,
it cloud be ask whether a topic is exists or not
