controller history

To facilitate update and rollback for controllers, and to provide a primitive
that third-party controllers can build on. History provide a mechanism that 
allow controllers to manage a bounded history of revision to the declared target
state of their target objects.


controller has history:
1 The specification type of a controller is the type that contains the specification 
for the Objects generated by the controller.
2 The generated type(s) for a controller is/are the type of the Object(s) generated 
by the controller. 
3 The current state of a controller is the union of the states of its generated Objects 
along with its status.

type ControllerRevision struct {
    metav1.TypeMeta
    // +optional
    metav1.ObjectMeta
    // Data contains the serialized state.
    Data runtime.RawExtension
    // Revision indicates the revision of the state represented by Data.
    Revision int64
}

Controllers
When a controller detects a revision to the target Object state of a specification 
type Object it will do the following.
1 create a snapshot of the current target object state.
2 reconstruct the history of revisions to the Object's target Object state
3 test the current target Object state for equivalence with all other versions in the Object's revision history.
4 reconcile its generated Objects with the new target Object state.
5 maintain the length of its history to be less than the configured limit. 


example:
in deployment:
spec:
    strategy:
        type: RollingUpdate
    revisionHistoryLimit: 5


$k create -f deploy.yaml --record
$k set image deployment vanguard vanguard=bikecn81/vanguard:0.2.9 --record -n ben
$k rollout history deploy/vanguard -n ben
deployment.extensions/vanguard 
REVISION  CHANGE-CAUSE
1         kubectl create --filename=rollout.yaml --record=true
2         kubectl set image deployment vanguard vanguard=bikecn81/vanguard:0.2.9 --record=true --namespace=ben


$k rollout undo deploy vanguard -n ben --to-revision=1
$k rollout history deploy/vanguard -n ben
deployment.extensions/vanguard 
REVISION  CHANGE-CAUSE
2         kubectl set image deployment vanguard vanguard=bikecn81/vanguard:0.2.9 --record=true --namespace=ben
3         kubectl create --filename=rollout.yaml --record=true


$k get rs -n ben -o wide
NAME                  DESIRED   CURRENT   READY   AGE   CONTAINERS   IMAGES                    SELECTOR
vanguard-55f4f658f4   2         2         2       20m   vanguard     bikecn81/vanguard:0.2.9   app=user-dns,pod-template-hash=55f4f658f4
vanguard-6947bb68c6   0         0         0       24m   vanguard     bikecn81/vanguard:0.1.4   app=user-dns,pod-template-hash=6947bb68c6


each rs --> pod with two label
labels:
   app: user-dns
   pod-template-hash: 55f4f658f4
when deployment rollout to specified revision, related rs's replicas will be modified, it will start its own container with
specified parameter which decide the pod template hash.


When the users perform a rollback, i.e. kubectl rollout undo, the Deployment first looks at its existing ReplicaSets, 
regardless of their number of replicas. Then it finds the one with annotation deployment.kubernetes.io/revision that 
either contains the specified rollback revision number or contains the second largest revision number among all the 
ReplicaSets (current new ReplicaSet should obtain the largest revision number) if the user didn't specify any revision 
number (the user wants to rollback to the last change). Lastly, it starts scaling up that ReplicaSet it's rolling back to, 
and scaling down the current ones, and then update the revision counter and the rollout annotations accordingly.


Pausing and Resuming a Deployment

kubectl rollout pause deploy vanguard
//do some update to the deployment
kubectl rollout resume deploy vanguard
